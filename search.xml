<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>HTTP、HTTPS、HTTP/2</title>
    <url>/2020/03/22/http/</url>
    <content><![CDATA[<p><img src="https://hsutimes.club/usr/uploads/2018/09/3819489413.png" alt=""><br>最近项目完成了http到https的升级，期间还发生了一些小事故😂😂😂，正好最近在复习<a href="https://kingyinliang.github.io/PDF/%E5%9B%BE%E8%A7%A3HTTP+%E5%BD%A9%E8%89%B2%E7%89%88.pdf" target="_blank" rel="noopener">《图解HTTP》</a>，所以决定写篇文章，梳理一下http、https的区别，以及对http2.0和即将到来的http3.0的介绍。</p>
<a id="more"></a>

<h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>Http全称是Hypertext Transfer Protocol(超文本传输协议)，目前主流的http版本是1997年发布的HTTP/1.1。相较于之前的版本，HTTP1.1有以下相关优势。</p>
<h4 id="一、持久链接"><a href="#一、持久链接" class="headerlink" title="一、持久链接"></a>一、持久链接</h4><p>在http1.0中，每次http链接都要进行tcp的三次握手和四次挥手。如果请求数不多，到时没啥影响。如果请求数多，那么请求的总时间就会大大延长，这对于用户体验来说，是非常糟糕的，因为用户可以会长时间看到空白的页面，或者，一个操作迟迟没有响应。<br>于是在1.1中，便支持了持久链接（keep-alive）。当第一次链接之后，如果客户端&amp;服务端都没有进行断开的操作，那么tcp链接就一直保持。这样，当多请求的时候，浏览器的速度就会快很多.<br>在http/1.1中，所有的请求默认都是持久链接。</p>
<h4 id="二、管线化"><a href="#二、管线化" class="headerlink" title="二、管线化"></a>二、管线化</h4><p>持久连接使得多数请求以管线化（pipelining）方式发送成为可能。从前发送请求后需要等待并收到响应，才能发送下一个请求。管道化技术出现以后，不用等待响应亦可以直接发送下一个请求。<br>这样就能够做到同时并行发送多个请求，而不需要一个接一个地等待响应了。</p>
<h4 id="三、使用多个tcp链接"><a href="#三、使用多个tcp链接" class="headerlink" title="三、使用多个tcp链接"></a>三、使用多个tcp链接</h4><p>http1.1可以同时开多个tcp链接。这样就可以做到并行。不过，由于浏览器的限制，每个域名的tcp链接最多只有6个。<br>如果页面想要多开tcp链接，只需要再添加域名增加tcp链接数即可（tcp链接是要域名区分）</p>
<hr>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>http虽然有上述提到的一些优点，但它也存在不足之处。</p>
<ul>
<li>通信使用明文（不加密），内容可能会被窃听。</li>
<li>不验证通信方的身份，因此有可能遭遇伪装。<br>1、 无法确定请求发送至目标的web服务器是否是按真实意图返回响应的那台服务器。有可能是已伪装的Web服务器。<br>2、 无法确定响应返回到的客户端是否是按真实意图接收响应的那个客户端。有可能是已伪装的客户端。<br>3、 无法确定正在通信的对方是否具备访问权限。因为某些web服务器上保存着重要的信息，只想发给特定用户通信的权限。<br>4、 无法判定请求是来自对方，出自谁手。<br>5、 即使是无意义的请求也会照单全收，无法阻止海量请求下的Dos攻击（Denial of Service， 拒绝服务攻击）。</li>
<li>无法验明报文的完整性，所有有可能已经被篡改。</li>
</ul>
<p>为了解决上述的问题，<strong>HTTPS</strong>便出现了。<br>所谓HTTPS, 就是HTTP+加密+认证+完整性保护，在http的部分通信接口采用SSL(Secure Socket Layer, 安全套接层)或TLS(Transport Layer Security, 安全传输层协议), 使用数字证书认证机构和其他相关机关颁发的公开秘钥证书。<br><img src="https://raw.githubusercontent.com/wq931030/albums/master/2019/20200322153525.png" alt=""><br>通常，HTTP直接和TCP通信。当使用SSL时，则演变成先和SSL通信，再由SSL和TCP通信了。<br>虽然，https能够确保请求的安全，但是它也是存在一些问题：<br><img src="https://raw.githubusercontent.com/wq931030/albums/master/2019/20200322154120.png" alt=""><br>与纯文本通信相比，加密通信会消耗更多的CPU及内存资源。如果每次通信都加密，会消耗相当多的资源，上面的图显示HTTPS比HTTP要慢2到100倍。所以，如果是非敏感信息可以使用Http通信。</p>
<hr>
<h3 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h3><p> ⚠️ 在1.1协议中 <strong>[浏览器客户端同一时间，针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞]</strong><br>所以HTTP/2，就为了解决上述问题而诞生。</p>
<h4 id="二进制分帧"><a href="#二进制分帧" class="headerlink" title="二进制分帧"></a>二进制分帧</h4><p>HTTP/2 采用二进制格式传输数据，而非 HTTP 1.x 的文本格式，二进制协议解析起来更高效。 HTTP / 1 的请求和响应报文，都是由起始行，首部和实体正文（可选）组成，各部分之间以文本换行符分隔。HTTP/2 将请求和响应数据分割为更小的帧，并且它们采用二进制编码。<br><strong>HTTP/2 中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流。</strong>每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装。</p>
<h4 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h4><p>HTTP 1.x 中所有就是请求的都是通过一个 TCP连接并发完成。如果想并发多个请求，必须使用多个 TCP 链接，且浏览器为了控制资源，还会对单个域名有 6-8个的TCP链接请求限制。<br>在 HTTP/2 中，有了二进制分帧之后，HTTP /2 不再依赖 TCP 链接去实现多流并行了，在 HTTP/2中：</p>
<ul>
<li>同域名下所有通信都在单个连接上完成。</li>
<li>单个连接可以承载任意数量的双向数据流。</li>
<li>数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。</li>
</ul>
<p>这一特性，使性能有了极大提升：</p>
<ul>
<li>同个域名只需要占用一个 TCP 连接，消除了因多个 TCP 连接而带来的延时和内存消耗。</li>
<li>单个连接上可以并行交错的请求和响应，之间互不干扰。</li>
<li>在HTTP/2中，每个请求都可以带一个31bit的优先值，0表示最高优先级， 数值越大优先级越低。有了这个优先值，客户端和服务器就可以在处理不同的流时采取不同的策略，以最优的方式发送流、消息和帧。</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2017/8/3/114b9871f433b7d5bbd4bb10faffea14?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""><br>官方演示说明， 同时请求 379 张图片，从Load time 的对比可以看出 HTTP/2 在速度上的优势。</p>
<h4 id="首部数据压缩"><a href="#首部数据压缩" class="headerlink" title="首部数据压缩"></a>首部数据压缩</h4><p>HTTP1.1 不支持 header 数据的压缩，HTTP2.0 使用 HPACK 算法对 header 的数据进行压缩，这样数据体积小了，在网络上传输就会更快。</p>
<h4 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h4><p>服务端可以在发送页面HTML时主动推送其它资源，而不用等到浏览器解析到相应位置，发起请求再响应。例如服务端可以主动把JS和CSS文件推送给客户端，而不需要客户端解析HTML时再发送这些请求。<br>服务端可以主动推送，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送RST_STREAM帧来拒收。主动推送也遵守同源策略，服务器不会随便推送第三方资源给客户端。</p>
<hr>
<h3 id="HTTP3-0"><a href="#HTTP3-0" class="headerlink" title="HTTP3.0"></a>HTTP3.0</h3><p>因为HTTP/2 根本上还是基于TCP连接的，所以还是存在每次请求前三次握手的性能消耗，而HTTP3.0引入的是谷歌主导开发的QUIC协议（快速UDP网络连接）, 抛弃了tcp.</p>
<h4 id="QUIC新功能"><a href="#QUIC新功能" class="headerlink" title="QUIC新功能"></a>QUIC新功能</h4><p>上面我们提到QUIC基于UDP，而UDP是“无连接”的，根本就不需要“握手”和“挥手”，所以就比TCP来得快。此外QUIC也实现了可靠传输，保证数据一定能够抵达目的地。它还引入了类似HTTP/2的“流”和“多路复用”，单个“流”是有序的，可能会因为丢包而阻塞，但其他“流”不会受到影响。具体来说QUIC协议有以下特点：</p>
<ul>
<li>实现了类似TCP的流量控制、传输可靠性的功能。</li>
</ul>
<p>虽然UDP不提供可靠性的传输，但QUIC在UDP的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些TCP中存在的特性。</p>
<ul>
<li>实现了快速握手功能。</li>
</ul>
<p>由于QUIC是基于UDP的，所以QUIC可以实现使用0-RTT或者1-RTT来建立连接，这意味着QUIC可以用最快的速度来发送和接收数据，这样可以大大提升首次打开页面的速度。0RTT 建连可以说是 QUIC 相比 HTTP2 最大的性能优势。</p>
<ul>
<li>集成了TLS加密功能。</li>
<li>多路复用，彻底解决TCP中队头阻塞的问题</li>
</ul>
<p>和TCP不同，QUIC实现了在同一物理连接上可以有多个独立的逻辑数据流（如下图）。实现了数据流的单独传输，就解决了TCP中队头阻塞的问题。</p>
]]></content>
      <tags>
        <tag>Http</tag>
      </tags>
  </entry>
  <entry>
    <title>Koa && Egg</title>
    <url>/2020/03/17/koa-1/</url>
    <content><![CDATA[<p><strong>Born to build</strong><br><strong>egg</strong> - better enterprise frameworks and apps with Node.js &amp; Koa</p>
<blockquote>
<p>为企业级框架和应用而生</p>
</blockquote>
<a id="more"></a>

<h3 id="1、什么是Egg"><a href="#1、什么是Egg" class="headerlink" title="1、什么是Egg"></a>1、什么是Egg</h3><p><a href="https://eggjs.org/" target="_blank" rel="noopener">Egg.js</a>是阿里开源的基于Koajs的框架，所以它应当属于框架之上的框架，它继承了Koajs的高性能优点，同时又加入了一些约束与开发规范，来规避Koajs框架本身的开发自由度太高的问题。</p>
<p><img src="https://koa.bootcss.com/public/images/koa-logo.png" alt=""></p>
<blockquote>
<p>Koa – 基于 Node.js 平台的下一代 web 开发框架</p>
</blockquote>
<h3 id="2、认识Koa"><a href="#2、认识Koa" class="headerlink" title="2、认识Koa"></a>2、认识Koa</h3><p><a href="https://koa.bootcss.com/" target="_blank" rel="noopener">Koa</a> 是一个新的 web 框架，由 Express 幕后的原班人马打造，致力于成为 web 应用和 API 开发领域中的一个更小、更富有表现力、更健壮的基石。通过利用 async 函数，Koa 帮你丢弃回调函数，并有力地增强错误处理。Koa 并没有捆绑任何中间件，而是提供了一套优雅的方法，帮助您快速而愉快地编写服务端应用程序。</p>
<h4 id="创建koa应用"><a href="#创建koa应用" class="headerlink" title="创建koa应用"></a>创建koa应用</h4><blockquote>
<p><strong>koa</strong>应用程序是一个包含一组中间件函数的对象，它是按照类似堆栈的方式组织和执行的。</p>
</blockquote>
<p>hello world:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// demo2</span></span><br><span class="line"><span class="keyword">const</span> koa = <span class="built_in">require</span>(<span class="string">'koa'</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> koa()</span><br><span class="line">app.use(<span class="function"><span class="params">ctx</span> =&gt;</span> &#123;</span><br><span class="line">  ctx.body = <span class="string">'Hello World'</span></span><br><span class="line">&#125;)</span><br><span class="line">app.listen(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure>
<h4 id="1、中间件"><a href="#1、中间件" class="headerlink" title="1、中间件"></a>1、中间件</h4><p>中间件其实就是一个函数, 它可以访问请求对象，响应对象和web应用中处于请求-响应循环流程中的中间件。<br><strong>Koa的中间件和Express不同，采用的是洋葱圈模型（Express是基于回调的线性模型）</strong><br><img src="https://camo.githubusercontent.com/d80cf3b511ef4898bcde9a464de491fa15a50d06/68747470733a2f2f7261772e6769746875622e636f6d2f66656e676d6b322f6b6f612d67756964652f6d61737465722f6f6e696f6e2e706e67" alt=""><br><img src="https://image-static.segmentfault.com/247/407/2474077171-5ab493c984bf8_articlex" alt=""><br>所有的请求经过一个中间件的时候都会执行两次。</p>
<blockquote>
<p>中间件执行顺序:</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//demo9</span></span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">6</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'listenning on 3000'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>多个中间件会形成一个栈结构（middle stack），以”先进后出”（first-in-last-out）的顺序执行。</p>
<p>1、最外层的中间件首先执行。<br>2、调用next函数，把执行权交给下一个中间件来’next’返回值<br>3、…<br>4、最内层的中间件最后执行。<br>执行结束后，把执行权交回上一层的中间件。<br>5、…<br>6、最外层的中间件收回执行权之后，执行next函数后面的代码</p>
<blockquote>
<p>中间件的合成</p>
</blockquote>
<p><strong>koa-compose</strong>模块可以将多个中间件合成为一个</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//demo 11</span></span><br><span class="line"><span class="keyword">const</span> compose = <span class="built_in">require</span>(<span class="string">'koa-compose'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> logger = <span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">Date</span>.now()&#125;</span> <span class="subst">$&#123;ctx.request.method&#125;</span> <span class="subst">$&#123;ctx.request.url&#125;</span>`</span>);</span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> main = <span class="function"><span class="params">ctx</span> =&gt;</span> &#123;</span><br><span class="line">  ctx.response.body = <span class="string">'Hello World'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> middlewares = compose([logger, main]);</span><br><span class="line">app.use(middlewares);</span><br></pre></td></tr></table></figure>
<p><strong>实现原理&gt;&gt;&gt;&gt;</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span> (<span class="params">middleware</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">context, next</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// last called middleware #</span></span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">return</span> dispatch(<span class="number">0</span>)</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (i &lt;= index) <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'next() called multiple times'</span>))</span><br><span class="line">      index = i</span><br><span class="line">      <span class="keyword">let</span> fn = middleware[i]</span><br><span class="line">      <span class="keyword">if</span> (i === middleware.length) fn = next</span><br><span class="line">      <span class="keyword">if</span> (!fn) <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve()</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(fn(context, dispatch.bind(<span class="literal">null</span>, i + <span class="number">1</span>)));</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dispatch函数将遍历整个middleware，然后将context和dispatch(i + 1)传给middleware中的方法。<br>从而实现</p>
<ul>
<li>将<code>context</code>一路传下去给中间件</li>
<li>将<code>middleware</code>中的下一个中间件<code>fn</code>作为未来<code>next</code>的返回值</li>
</ul>
<hr>
<h4 id="2、Context"><a href="#2、Context" class="headerlink" title="2、Context"></a>2、Context</h4><p>和 Express 只有 Request 和 Response 两个对象不同，Koa 增加了一个 Context 的对象，作为这次请求的上下文对象,我们可以将一次请求相关的上下文都挂载到这个对象上</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> main = <span class="function"><span class="params">ctx</span> =&gt;</span> &#123;</span><br><span class="line">  ctx.response.body = <span class="string">'Hello World'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">app.use(main);</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
<p>main函数用来设置ctx.response.body。ctx.response代表http response。同样的，ctx.request代表http request</p>
<p>同时 Context 上也挂载了 Request 和 Response 两个对象。和 Express 类似，这两个对象都提供了大量的便捷方法辅助开发，例如:</p>
<ul>
<li>get request.query</li>
<li>get request.hostname</li>
<li>set response.body</li>
<li>set response.status</li>
</ul>
<hr>
<h4 id="3、路由"><a href="#3、路由" class="headerlink" title="3、路由"></a>3、路由</h4><p>网站一般有多个页面/接口，通过ctx.request.path获取用户请求的路径来实现简单的路由。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//demo5</span></span><br><span class="line"><span class="keyword">const</span> main = <span class="function"><span class="params">ctx</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (ctx.request.path !== <span class="string">'/'</span>) &#123;</span><br><span class="line">    ctx.response.type = <span class="string">'html'</span>;</span><br><span class="line">    ctx.response.body = <span class="string">'&lt;a href="/"&gt;Index Page&lt;/a&gt;'</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ctx.response.body = <span class="string">'Hello World'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="koa-router"><a href="#koa-router" class="headerlink" title="koa-router"></a>koa-router</h5><p>原生实现koa路由比较繁琐，可以用<a href="https://github.com/ZijianHe/koa-router" target="_blank" rel="noopener">koa-router</a>中间件来处理url映射，从而实现命名路由、命名参数、多路由中间件，嵌套路由等多种功能。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// demo6</span></span><br><span class="line"><span class="keyword">const</span> about = <span class="function"><span class="params">ctx</span> =&gt;</span> &#123;</span><br><span class="line">  ctx.response.type = <span class="string">'html'</span>;</span><br><span class="line">  ctx.response.body = <span class="string">'&lt;a href="/"&gt;Index Page&lt;/a&gt;'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> main = <span class="function"><span class="params">ctx</span> =&gt;</span> &#123;</span><br><span class="line">  ctx.response.body = <span class="string">'Hello World'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">app.use(route.get(<span class="string">'/'</span>, main));</span><br><span class="line">app.use(route.get(<span class="string">'/about'</span>, about));</span><br></pre></td></tr></table></figure>
<h4 id="4、错误处理"><a href="#4、错误处理" class="headerlink" title="4、错误处理"></a>4、错误处理</h4><blockquote>
<p>500错误</p>
</blockquote>
<p>koa提供了ctx.throw()方法，用来抛出错误</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// demos/14.js</span></span><br><span class="line"><span class="keyword">const</span> main = <span class="function"><span class="params">ctx</span> =&gt;</span> &#123;</span><br><span class="line">  ctx.throw(<span class="number">500</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>404</p>
</blockquote>
<p>将ctx.response.status设置成404，就相当于ctx.throw(404)，返回404错误。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// demos/15.js</span></span><br><span class="line"><span class="keyword">const</span> main = <span class="function"><span class="params">ctx</span> =&gt;</span> &#123;</span><br><span class="line">  ctx.response.status = <span class="number">404</span>;</span><br><span class="line">  ctx.response.body = <span class="string">'Page Not Found'</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 处理错误的中间件</p>
</blockquote>
<p>通过同步方式编写异步代码带来的另外一个非常大的好处就是异常处理非常自然，使用 try catch 就可以将按照规范编写的代码中的所有错误都捕获到。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//demo16</span></span><br><span class="line"><span class="keyword">const</span> handle = <span class="keyword">async</span>(ctx, next) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    ctx.app.emit(<span class="string">'error'</span>, err);</span><br><span class="line">    ctx.body = <span class="string">'server error'</span>;</span><br><span class="line">    ctx.status = err.status || <span class="number">500</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> main = <span class="function"><span class="params">ctx</span> =&gt;</span> &#123;</span><br><span class="line">    ctx.throw(<span class="number">500</span>)</span><br><span class="line">&#125;</span><br><span class="line">app.use(handle)</span><br><span class="line">app.use(main)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>error事件监听</p>
</blockquote>
<p>运行过程中一旦出错，koa会触发一个error事件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//demo17</span></span><br><span class="line"><span class="keyword">const</span> main = <span class="function"><span class="params">ctx</span> =&gt;</span> &#123;</span><br><span class="line">  ctx.throw(<span class="number">500</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">app.on(<span class="string">'error'</span>, (err, ctx) =&gt;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">'server error'</span>, err);</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>主动触发</p>
</blockquote>
<p>当错误被try…catch捕获时，就不会触发koa的error事件。当我们catch捕获到错误时，可以手动触发error事件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//demo18</span></span><br><span class="line"><span class="keyword">const</span> handler = <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    ctx.response.status = err.statusCode || err.status || <span class="number">500</span>;</span><br><span class="line">    ctx.response.type = <span class="string">'html'</span>;</span><br><span class="line">    ctx.response.body = <span class="string">'&lt;p&gt;Something wrong, please contact administrator.&lt;/p&gt;'</span>;</span><br><span class="line">    ctx.app.emit(<span class="string">'error'</span>, err, ctx);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> main = <span class="function"><span class="params">ctx</span> =&gt;</span> &#123;</span><br><span class="line">  ctx.throw(<span class="number">500</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">app.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'logging error '</span>, err.message);</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript学习笔记-上</title>
    <url>/2020/03/09/typescript1-0/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/wq931030/albums/master/2019/2018-12-25-ts.jpeg" alt=""><br>2020了，typescript可以说是现在前端界的趋势所在。各大厂，各个主流框架也都开始全面拥抱TypeScript,包括Q2季度将要发布的vue3.0。所以，为了提升自己（顺应潮流，能看得懂源码😭），我们就撸起袖子来好好学习一下TypeScript吧。</p>
<a id="more"></a>
<p>鉴于TypeScript知识点比较多，所以，打算分三波来学习。<strong>Let’s Go!</strong></p>
<blockquote>
<p>这篇文章主要介绍typescript的一些基本类型，然后看一下ts是怎么做类型推导的，对TypeScript有个大概的了解</p>
</blockquote>
<hr>
<h3 id="全局安装"><a href="#全局安装" class="headerlink" title="全局安装"></a>全局安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g typescript</span><br></pre></td></tr></table></figure>
<p>编译ts文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tsc demo.ts</span><br></pre></td></tr></table></figure>
<p>如果想要编译并执行，可以下载ts-node</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g ts-node</span><br><span class="line">ts-node demo.ts</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="一、基础类型"><a href="#一、基础类型" class="headerlink" title="一、基础类型"></a>一、基础类型</h3><h4 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let isDone: boolean = false</span><br></pre></td></tr></table></figure>
<h4 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h4><blockquote>
<p>ts里面所有的数字都是浮点数。这些浮点数的类型都是number。支持包括十进制，十六进制，二进制和八进制。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let decLiteral: number = 6</span><br><span class="line">let hexLiteral: number = 0xf00d</span><br><span class="line">let binaryLiteral: number = 0n1010</span><br><span class="line">let octalLiteral: number = 0o744</span><br></pre></td></tr></table></figure>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let name: string = &apos;Tom&apos;</span><br><span class="line">let sentence: string = `My name is $&#123;name&#125;`</span><br></pre></td></tr></table></figure>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>ts中有两种定义数组的方法。第一种，在元素类型后面接上[],表示由此类型元素组成的一个数组;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let list: number[] = [1, 2, 3]</span><br></pre></td></tr></table></figure>
<p>第二种，使用数组泛型，Array&lt;元素类型&gt;;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let list: Array&lt;string&gt; = [&apos;f&apos;, &apos;b&apos;, &apos;m&apos;]</span><br></pre></td></tr></table></figure>
<h4 id="元祖-Tuple"><a href="#元祖-Tuple" class="headerlink" title="元祖 Tuple"></a>元祖 Tuple</h4><p>元祖类型允许表示一个已知数量和类型的数组，各元素类型不必相同。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a: [string, number] = [&apos;d3&apos;, 3]</span><br></pre></td></tr></table></figure>
<p>访问一个已知索引，可以得到正确的类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(a[0].substr(1)) // 3</span><br><span class="line">console.log(a[1].substr(1)) // 类型“number”上不存在属性“substr”。</span><br></pre></td></tr></table></figure>
<h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p>enum是对JS标准数据类型的补充，可以使用枚举类型为一组数值赋予名字。ts支持数字和基于字符串的枚举。</p>
<h5 id="数字枚举：-默认情况，从0开始为元素编号。也可以手动指定"><a href="#数字枚举：-默认情况，从0开始为元素编号。也可以手动指定" class="headerlink" title="数字枚举： 默认情况，从0开始为元素编号。也可以手动指定"></a><strong>数字枚举：</strong> 默认情况，从0开始为元素编号。也可以手动指定</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum Res &#123; No = 0, Yes = 1 &#125;</span><br><span class="line">console.log(&apos;c: &apos;, Res.Yes)</span><br></pre></td></tr></table></figure>
<h5 id="反向映射"><a href="#反向映射" class="headerlink" title="反向映射"></a>反向映射</h5><p>数字枚举成员具有反向映射，可以从枚举值到枚举名字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum Enum &#123;</span><br><span class="line">  A</span><br><span class="line">&#125;</span><br><span class="line">let a = Enum.A</span><br><span class="line">let nameOfA = Enum[a] // A</span><br></pre></td></tr></table></figure>
<h5 id="字符串枚举：在一个字符串枚举里，每个成员都必须用字符串字面，或另外一个字符串枚举成员进行初始化。"><a href="#字符串枚举：在一个字符串枚举里，每个成员都必须用字符串字面，或另外一个字符串枚举成员进行初始化。" class="headerlink" title="字符串枚举：在一个字符串枚举里，每个成员都必须用字符串字面，或另外一个字符串枚举成员进行初始化。"></a><strong>字符串枚举：</strong>在一个字符串枚举里，每个成员都必须用字符串字面，或另外一个字符串枚举成员进行初始化。</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum Direction &#123;</span><br><span class="line">  Up = &apos;UP&apos;,</span><br><span class="line">  Down = &apos;DOWN&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="异构枚举：混合字符串和数字的枚举"><a href="#异构枚举：混合字符串和数字的枚举" class="headerlink" title="异构枚举：混合字符串和数字的枚举"></a><strong>异构枚举：</strong>混合字符串和数字的枚举</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum BooleanLikeHeterogeneousEnum &#123;</span><br><span class="line">    No = 0,</span><br><span class="line">    Yes = &quot;YES&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="联合枚举与枚举成员的类型"><a href="#联合枚举与枚举成员的类型" class="headerlink" title="联合枚举与枚举成员的类型"></a><strong>联合枚举与枚举成员的类型</strong></h5><h4 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h4><p>用于为在编程阶段还不清楚的变量指定类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let notSure: any = 4</span><br><span class="line">notSure = &apos;maybe a string instead&apos;</span><br><span class="line">notSure = false</span><br><span class="line">let list: any[] = [1, &apos;ff&apos;, false]</span><br></pre></td></tr></table></figure>
<h4 id="Void"><a href="#Void" class="headerlink" title="Void"></a>Void</h4><p>表示美誉任何类型。当一个函数没有返回值时，可以设置返回值类型为void</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function test() : void &#123;</span><br><span class="line">  console.log(&apos;test&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h4><p>当确定知道一个值的类型时，可以使用类型断言。类似于类型转换<br>一般有两种方式实现。<br>第一种，“尖括号”语法”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let value: any = &apos;string&apos;</span><br><span class="line">let strLength: number = (&lt;string&gt;value).length</span><br></pre></td></tr></table></figure>
<p>第二种，”as”语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let value: any = &apos;string&apos;</span><br><span class="line">let strLength: number = (value as string).length</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="二、接口"><a href="#二、接口" class="headerlink" title="二、接口"></a>二、接口</h3><p>ts的核心原则之一就是对值所具有的结构进行类型检查，而接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。（鸭式辨型发）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface LabeledValue &#123;</span><br><span class="line">  label: string;</span><br><span class="line">&#125;</span><br><span class="line">function printLabel(labelObj: LabeledValue) &#123;</span><br><span class="line">  console.log(labelObj.label)</span><br><span class="line">&#125;</span><br><span class="line">let myObj = &#123;size: 10, label: &apos;size 10&apos;&#125;</span><br><span class="line">printLabel(myObj)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可选属性</p>
</blockquote>
<p>接口里的属性不全是必需的，可以使用“option bags”模式()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface LabeledValue &#123;</span><br><span class="line">  label: string;</span><br><span class="line">  size?: string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>只读属性</p>
</blockquote>
<p>在属性名前用readonly来指定只读属性　</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface LabeledValue &#123;</span><br><span class="line">  readonly label: string;</span><br><span class="line">  size?: string;</span><br><span class="line">&#125;</span><br><span class="line">let l: LabelValue = &#123; label: &apos;color&apos; &#125;</span><br><span class="line">l.label = &apos;dimension&apos; // error</span><br></pre></td></tr></table></figure>
<h4 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h4><p>接口不但可以描述普通对象，也可以描述函数类型。使用时，需要给接口定义一个调用签名。类似于一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface someFunc &#123; </span><br><span class="line">  (source: string, subString: string): boolean</span><br><span class="line">&#125;</span><br><span class="line">let myFunc: someFunc</span><br><span class="line">myFunc = function(src:string, sub:string) &#123;</span><br><span class="line">  let result = src.search(sub);</span><br><span class="line">  return result &gt; -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="可索引的类型"><a href="#可索引的类型" class="headerlink" title="可索引的类型"></a>可索引的类型</h4><p>可索引类型具有一个<strong>索引签名</strong>,它描述了对象索引的类型，还有相应的索引返回值类型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface StringArray &#123;</span><br><span class="line">  [index: number]: string</span><br><span class="line">&#125;</span><br><span class="line">let myArray: StringArray</span><br><span class="line">myArray = [&apos;Bob&apos;, &apos;Tom&apos;]</span><br><span class="line">let myStr: string = myArray[0] // Bob</span><br></pre></td></tr></table></figure>
<p>ts支持两种索引签名：字符串和数字。可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的自类型。因为，当使用<strong>number</strong>来索引是，js会将它转化为string然后再去索引对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    name: string;</span><br><span class="line">&#125;</span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">    breed: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 错误：使用数值型的字符串索引，有时会得到完全不同的Animal!</span><br><span class="line">interface NotOkay &#123;</span><br><span class="line">    [x: number]: Animal;</span><br><span class="line">    [x: string]: Dog;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h4><p>与java里接口的基本作用一样，ts可以用来明确的墙纸一个类去符合某种契约。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface ClockConstructor &#123;</span><br><span class="line">  curTime: Date;</span><br><span class="line">  setTime(d: Date);</span><br><span class="line">&#125;</span><br><span class="line">class Clock implements ClockConstructor &#123;</span><br><span class="line">  curTime: Date;</span><br><span class="line">  setTime(d: Date) &#123;</span><br><span class="line">    this.ctrTime = d</span><br><span class="line">  &#125;</span><br><span class="line">  constructor(h:number, m:number) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以在接口中描述一个方法，然后在类里面实现它</p>
<h4 id="继承接口"><a href="#继承接口" class="headerlink" title="继承接口"></a>继承接口</h4><p>和类一样，接口也可以相互继承。这样，我们就能够从一个接口里复制成员到另一个接口里，可以灵活地将接口分割到可重用的模块里</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface shape &#123;</span><br><span class="line">  color: string;</span><br><span class="line">&#125;</span><br><span class="line">interface Square extends Shape &#123;</span><br><span class="line">  sideLength: number;</span><br><span class="line">&#125;</span><br><span class="line">let square = &lt;Square&gt;&#123;&#125;</span><br><span class="line">square.color = &quot;blue&quot;</span><br><span class="line">square.sideLength = 10</span><br></pre></td></tr></table></figure>
<p><strong>下一章，我们继续来深入学习类，函数，范型这些知识（都涉及到继承相关的知识）。其实ts的这些内容和java很像，如果之前有了解java相关的内容，理解起来会比较容易！</strong></p>
]]></content>
      <tags>
        <tag>Typescript</tag>
      </tags>
  </entry>
  <entry>
    <title>《菊与刀》</title>
    <url>/2020/03/06/read-02/</url>
    <content><![CDATA[<p><img src="https://58generalclass.files.wordpress.com/2017/06/640.jpg" alt=""></p>
<blockquote>
<p>菊”本是日本皇室家徽，“刀”是武士道文化的象征。美国人类学家鲁思・本尼迪克特用《菊与刀》来揭示日本人的矛盾性格亦即日本文化的双重性 一 <em>豆瓣评分</em>：<strong>8.2</strong></p>
</blockquote>
<a id="more"></a>

<ul>
<li><p>日本人对于精神依赖已经达到一种变态的地步，基本上完全否认对于物质的依赖。在战时，支撑日本军人的就是他们所谓的胜利信念。他们认为日本对中国发动战争，是为了解救中国人，实现所谓的大东亚共荣。</p>
</li>
<li><p>天皇对于日本人来说，是一种不可侵犯的至高无上的象征。战后，他们会批判军队，批判政府官员，但是对于天皇，他们认为，天皇不需要对战争付出任何责任。</p>
</li>
<li><p>日本军人认为投降，成为俘虏是一件比死还要可怕的事情，宁可玉碎，也不投降。</p>
</li>
<li><p>日本人信奉所谓的各安其位，各得其所的信条，并且在侵略战争中也一直以该信条作为发动战争的基本原则，认为对中国发动战争，是要把中国人放在合适的位置。</p>
</li>
<li><p>日本人尊崇严格的等级制度，并且这种等级制度是从家庭范围开始从小培养的。<br>在日本家庭里，信奉长兄如父，一家的长子有权对家庭成员的人生安排作出他认为对于这个家族有利的规划。</p>
</li>
<li><p>在日本幕府时代，尊崇士农工商的阶级地位（和中国早期封建社会一样），尽管商人很富有，但是社会地位确实最底下的。所以会出现富裕的商人与贫困的武士进行联姻的情况，从而达到商人阶级提高自己社会地址的效果。</p>
</li>
<li><p>天皇没有任何政治上的实权，国家的一切权利全部掌握在幕府将军的手中，但是这并不意味着天皇就没有存在的意义。相反，在日本人心中，天皇是一种至高无上的象征。</p>
</li>
<li><p>日本的武士，也就是所谓的家臣，是完全被自己的主人豢养的（类似于春秋战国时期的门客）。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Reading</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS Grid Layout</title>
    <url>/2020/02/27/css-grid/</url>
    <content><![CDATA[<p>工作中用到的最多的布局就是flex布局了，对于grid的了解不是很多。所以，今天打算好好地深入了解一下这个新一代的布局神器。</p>
<a id="more"></a>
<p>首先祭上<a href="https://caniuse.com/css-grid/embed" target="_blank" rel="noopener">浏览器兼容性</a></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><hr>
<p><strong>CSS 网格布局</strong>擅长于将一个页面划分为几个主要区域，以及定义这些区域的大小、位置、层次等关系（前提是HTML生成了这些区域）。</p>
<p>像表格一样，网格布局让我们能够按行或列来对齐元素。 然而在布局上，网格比表格更可能做到或更简单。 例如，网格容器的子元素可以自己定位，以便它们像CSS定位的元素一样，真正的有重叠和层次。</p>
<blockquote>
<p>来源：<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout" target="_blank" rel="noopener">MDN</a></p>
</blockquote>
<hr>
<h3 id="网格容器"><a href="#网格容器" class="headerlink" title="网格容器"></a>网格容器</h3><p>当我们在元素上声明display: grid或display: inline-grid时，这个元素就成为了网格容器，它所有的直系子元素就是网格元素。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"one"</span>&gt;</span>One<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"two"</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"three"</span>&gt;</span>Three<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"four"</span>&gt;</span>Four<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"five"</span>&gt;</span>Five<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="网格轨道"><a href="#网格轨道" class="headerlink" title="网格轨道"></a>网格轨道</h3><p>通过grid-template-columns和grid-template-rows属性可以定义网格容器的行列。这些属性定义了网格的轨道。一个网格轨道就是网格中任意两条线之间的空间。<br>通常，grid-template-columns和grid-template-rows的属性值可以是长度（px, em, rem, vm），百分比，也可以是特殊单位：fr(代表网格中国呢自由空间的份数)<br>同时，你还可以设置这个轨道的名字：grid-template-columns: [start] 20px [middle] 40px [end] 50px;<br>默认情况下，可以不设置名字，当设置名字是，必须用[]包裹。<br>下面这个例子，创建了一个包含三个200px的列轨道网格布局</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'wrapper'</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>5<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>6<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: [line] <span class="number">200px</span> [line] <span class="number">200px</span> [line] <span class="number">200px</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你定义了容器的重复部分，可以使用 <strong>repeat()</strong>方法来生成多个相同的值，上面的样式也可以这样写</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(3, 200px [line]) <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="repeat-扩展"><a href="#repeat-扩展" class="headerlink" title="repeat 扩展"></a>repeat 扩展</h4><p>repeat()还支持auto-fill和auto-fit</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-columns</span>: <span class="selector-tag">repeat</span>( 12, <span class="selector-tag">minmax</span>(250<span class="selector-tag">px</span>, 1<span class="selector-tag">fr</span>) );</span><br></pre></td></tr></table></figure>
<p>上面的css，它的意思是让容器分成12份，每份至少250px<br>这时候，grid肯定会当前行内容移除，但是这些列却又不会自动换行，因为之前已经告诉浏览器必须有12份。<br>为了实现换行，可以用<strong>auto-fit</strong>或<strong>auto-fill</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-columns</span>: <span class="selector-tag">repeat</span>( <span class="selector-tag">auto-fit</span>, <span class="selector-tag">minmax</span>(250<span class="selector-tag">px</span>, 1<span class="selector-tag">fr</span>) );</span><br></pre></td></tr></table></figure>
<p>这条语句让浏览器自己去处理列宽和元素的换行，如果容器宽度不够，元素会自动换行。这里还是使用fr单位，这样的话，如果行内剩下的空间不足以容纳另外一列时，已有的列能自动占满一整行，不造成空间浪费。</p>
<h5 id="fill-和-fit的区别"><a href="#fill-和-fit的区别" class="headerlink" title="fill 和 fit的区别"></a>fill 和 fit的区别</h5><blockquote>
<p>auto-fill 倾向于容纳更多的列，所以如果在满足宽度限制的前提下还有空间能容纳新列，那么它会暗中创建一些列来填充当前行。即使创建出来的列没有任何内容，但实际上还是占据了行的空间。<br>  auto-fit 倾向于使用最少列数占满当前行空间，浏览器先是和 auto-fill 一样，暗中创建一些列来填充多出来的行空间，然后坍缩（collapse）这些列以便腾出空间让其余列扩张。</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.grid</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  grid-template-col</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="隐式和显式网格"><a href="#隐式和显式网格" class="headerlink" title="隐式和显式网格"></a>隐式和显式网格</h3><p>显式网格包含了你在 grid-template-columns 和 grid-template-rows 属性中定义的行和列。<br>当我们创建上文网格例子的时候，只用grid-template-columns定义了列轨道，让网格按照内容所需创建行，这些行会被创建在隐式网格中。</p>
<h4 id="显式网格"><a href="#显式网格" class="headerlink" title="显式网格"></a>显式网格</h4><p>对于显式网格，除了使用grid-template-columns 和 grid-template-rows，还可以使用template-grid-area搭配grid-area来定义<br><code>grid-template-areas: &quot;&lt;grid-area-name&gt; | . | none | ...&quot; &quot;...&quot;</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span>   </span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item-a"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>   </span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item-b"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>   </span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item-c"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>   </span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item-d"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>   </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;    </span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">200px</span>;   </span><br><span class="line">  <span class="attribute">display</span>:grid;   </span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(4, 1fr);   </span><br><span class="line">  <span class="attribute">grid-template-rows</span>: auto;   </span><br><span class="line">  <span class="attribute">grid-template-areas</span>: <span class="string">"header header header header"</span>   </span><br><span class="line"></span><br><span class="line">                       <span class="string">"main main . sidebar"</span>   </span><br><span class="line"></span><br><span class="line">                       <span class="string">"header footer header footer"</span>;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item-a</span>&#123;   </span><br><span class="line">  <span class="attribute">grid-area</span>: header;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="selector-class">.item-b</span>&#123;   </span><br><span class="line">  <span class="attribute">grid-area</span>: main; </span><br><span class="line">&#125; </span><br><span class="line"><span class="selector-class">.item-c</span>&#123;   </span><br><span class="line">  <span class="attribute">grid-area</span>: sidebar; </span><br><span class="line">&#125;  </span><br><span class="line"><span class="selector-class">.item-d</span>&#123;   </span><br><span class="line">  <span class="attribute">grid-area</span>: footer; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="隐式网格"><a href="#隐式网格" class="headerlink" title="隐式网格"></a>隐式网格</h4><p>对于隐式网格，可以用grid-auto-row和grid-auto-columns来定义轨道的大小</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span>&gt;</span>One<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span>&gt;</span>Three<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span>&gt;</span>Four<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span>&gt;</span>Five<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(3, 1fr);</span><br><span class="line">  <span class="attribute">grid-auto-rows</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子设置了每个轨道的高度都是200px</p>
<hr>
<h3 id="轨道大小和minmax"><a href="#轨道大小和minmax" class="headerlink" title="轨道大小和minmax()"></a>轨道大小和minmax()</h3><p>接着上面的例子，我们设置了每个格子的高度都是200px,但是如果轨道的尺寸是随着内容改变的话，这个时候我们就需要用到minmax()来动态设置轨道的尺寸。<br>minimax()：顾名思义，其实就是设置了一个区间，如果值设置为auto就说明是动态变化的<br>下面的例子，网格的高度就是最小100px,然后随着内容变化：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">.wrapper &#123;</span><br><span class="line">  display: grid;</span><br><span class="line">  grid-template-columns: repeat(3, 1fr);</span><br><span class="line">  grid-auto-rows: minmax(100px, auto);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="网格线"><a href="#网格线" class="headerlink" title="网格线"></a>网格线</h3><p>当我们创建网格的时候，grid会为我们创建编号的网格线来让我们定位每一个网格元素.<br>所以当我们要放置元素的时候，我们就要使用网格线。<br>基本上会用到下面几个属性：<br><strong>grid-column-start</strong>, <strong>grid-column-end</strong>, <strong>grid-row-start</strong>, <strong>grid-row-end</strong><br>下面的例子，第一个元素从列线1开始， 延伸至列线4，并从行线1延伸到行线3，占据了两个行轨道。<br>第二个元素从列线1开始，延伸了一个轨道。因为这是默认行为，所以我不用指定结束线。并且它从行线3到行线5，跨越了两个行轨道。剩下的元素会自动放到网格剩余的空间中。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box1"</span>&gt;</span>One<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box2"</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box3"</span>&gt;</span>Three<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box4"</span>&gt;</span>Four<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box5"</span>&gt;</span>Five<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123; </span><br><span class="line">    <span class="attribute">display</span>: grid; </span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(3, 1fr); </span><br><span class="line">    <span class="attribute">grid-auto-rows</span>: <span class="number">100px</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="selector-class">.box1</span> &#123; </span><br><span class="line">    <span class="attribute">grid-column-start</span>: <span class="number">1</span>; </span><br><span class="line">    <span class="attribute">grid-column-end</span>: <span class="number">4</span>; </span><br><span class="line">    <span class="attribute">grid-row-start</span>: <span class="number">1</span>; </span><br><span class="line">    <span class="attribute">grid-row-end</span>: <span class="number">3</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="selector-class">.box2</span> &#123; </span><br><span class="line">    <span class="attribute">grid-column-start</span>: <span class="number">1</span>; </span><br><span class="line">    <span class="attribute">grid-row-start</span>: <span class="number">3</span>; </span><br><span class="line">    <span class="attribute">grid-row-end</span>: <span class="number">5</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>《人间失格》</title>
    <url>/2020/01/30/read-01/</url>
    <content><![CDATA[<blockquote>
<p>“生而为人，我很抱歉”   ——太宰治</p>
</blockquote>
<a id="more"></a>
<p>&nbsp;&nbsp;&nbsp;&nbsp;第一次看到这句话，是在电影《被嫌弃的松子的一生》。<br>&nbsp;&nbsp;&nbsp;&nbsp;那个时候，看到这句话感触很深，所以就网上搜索了这句话。然后，就发现日本作家<a href="https://baike.baidu.com/item/%E5%A4%AA%E5%AE%B0%E6%B2%BB/5426741" target="_blank" rel="noopener">太宰治</a>写的这本<a href="https://book.douban.com/subject/4011670/" target="_blank" rel="noopener">《人间失格》</a>。把这本书放进想读书单也已经很久了，趁着去年双十二当当打折，最终还是买了一本。然后趁着这个春节假期，断断续续花了三天的时间，读完了这本书。<br>&nbsp;&nbsp;&nbsp;&nbsp;读完这本书最大的一个感受就是心疼男主-叶藏。因为不知道怎么表达自己想要的，不会拒绝别人，注定了叶藏悲惨的一生。<br>&nbsp;&nbsp;&nbsp;&nbsp;为了掩藏自己的真实想法，努力的在别人面前充当小丑的角色，坚硬的外壳下包裹的是一颗一触即碎的心。和松子一样，从小也是一个敏感的孩子，为了讨好别人，一直逼自己做自己不喜欢的事，以为可以得到幸福，但是到头来，却成了人人厌恶的“废人”<br>&nbsp;&nbsp;&nbsp;&nbsp;无聊的没有意义的日子日复一日, 所以：<strong>如今的我，谈不上幸福，也谈不上不幸。</strong></p>
<p style='text-align:center;color:gray;font-weight:bold;'> “相同之事也反复发生在明日<br>
只需遵从与昨天同样的惯例<br>
只要避免过度的狂喜<br>
自然不会有悲哀造次<br>
蟾蜍总是迂回前进<br>
躲开阻挡前方的路石”</p>
]]></content>
      <categories>
        <category>书单</category>
      </categories>
      <tags>
        <tag>Reading</tag>
      </tags>
  </entry>
  <entry>
    <title>按位操作符</title>
    <url>/2020/01/21/bitwise-operator/</url>
    <content><![CDATA[<p><strong>按位操作符</strong>将其操作数当作32位的比特序列（由0和1组成，也就是二进制），但是返回值依然是标准的javascript数值。</p>
<a id="more"></a>
<p>下表总结了JS中的按位操作符：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>用法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>按位与（AND）</td>
<td>a &amp; b</td>
<td>1、对于每一个比特位，只有两个操作数相应的比特位都是1时，结果才是1，否则为0  2、将任一数值 x 与 0 执行按位与操作，其结果都为 0。将任一数值 x 与 -1 执行按位与操作，其结果都为 x。</td>
</tr>
<tr>
<td>按位或（OR）</td>
<td>a / b</td>
<td>1、对于每一个比特位，当两个操作数相应的位至少有一个1时，结果为1，否则为0。 2、将任一数值 x 与 0 进行按位或操作，其结果都是 x。将任一数值 x 与 -1 进行按位或操作，其结果都为 -1</td>
</tr>
<tr>
<td>按位异或（XOR）</td>
<td>a ^ b</td>
<td>对于每一个比特位，当两个操作数相应的比特位有且只有一个1时，结果为1，否则为0。</td>
</tr>
<tr>
<td>按位非（NOT）</td>
<td>～a</td>
<td>反转操作数的比特位，即0变成1，1变成0</td>
</tr>
</tbody></table>
<h2 id="运用按位操作符，我们可以很容易的解决一些问题。"><a href="#运用按位操作符，我们可以很容易的解决一些问题。" class="headerlink" title="运用按位操作符，我们可以很容易的解决一些问题。"></a>运用按位操作符，我们可以很容易的解决一些问题。</h2><p>举个例子：<br>leeCode上有一道数组问题</p>
<blockquote>
<p><strong>只出现一次的数字</strong></p>
</blockquote>
<p>描述：给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。<br>说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？<br><strong>示例1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[2,2,1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>解题思路:</strong></p>
</blockquote>
<p>这道题目，我们可以用按位异或来解决：两个相同的数异或的结果是0，不相同时异或结果为1.0和其他数异或就是这个数本身。-1与X异或，其结果为-x。</p>
<blockquote>
<p><strong>题解</strong></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> singleNumber = <span class="function">(<span class="params">nums = []</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    nums[<span class="number">0</span>] = nums[<span class="number">0</span>] ^ nums[i]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>80%的前端都拎不清的Css选择器优先级</title>
    <url>/2019/12/29/css-selector/</url>
    <content><![CDATA[<p>没错，我就是一个标题党来着的（😄😄😄😄😄😄😄）。<br>是个前端开发工程师，就知道Css选择器，但是这么多的选择器，我们真的搞得的清楚彼此之间的优先级吗？<br>先来个小题先考考一下大家哈，如果有大佬已经很清楚答案以及原理，那就可以忽略这篇文章，如果你还不太清楚的，希望这片文章可以让你更好的理解Css的选择器优先级～～</p>
<a id="more"></a>
<p>废话不多说，上题👇</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh-CN"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span> <span class="attr">class</span>=<span class="string">'foo'</span>&gt;</span>颜色是？<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">body</span><span class="selector-class">.foo</span><span class="selector-pseudo">:not(</span><span class="selector-attr">[dir]</span>) &#123; <span class="attribute">color</span>: red; &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">html</span><span class="selector-attr">[lang]</span> &gt; <span class="selector-class">.foo</span> &#123; <span class="attribute">color</span>: blue; &#125;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在说出答案之前，我先来介绍一下css的选择器优先级规则以及计算规则：</p>
<hr>
<h4 id="CSS优先级规则概览"><a href="#CSS优先级规则概览" class="headerlink" title="CSS优先级规则概览"></a>CSS优先级规则概览</h4><p>1、 0级：通配选择器、选择符和逻辑组合伪类。其中，通配选择器写作星号（*）。示例如下👇:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* &#123; color: #000; &#125;</span><br></pre></td></tr></table></figure>
<p>选择符指+、&gt;、~、空格和||。<br>逻辑组合伪类有:not()、:is()和:where等，这些伪类本身并不影响CSS优先级，影响优先级的是括号里面的选择器。<br>2、 1级：标签选择器。示例如下👇:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">body &#123; color: #333; &#125;</span><br></pre></td></tr></table></figure>
<p>3、 2级：类选择器、属性选择器和伪类。示例如下👇:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.foo &#123; color: #666; &#125;</span><br><span class="line">[foo] &#123; color: #666; &#125;</span><br><span class="line">:hover &#123; color: #333; &#125;</span><br></pre></td></tr></table></figure>
<p>4、3级：ID选择器。示例如下👇:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#foo &#123; color: #666; &#125;</span><br></pre></td></tr></table></figure>
<p>5、4级：style属性内联。示例如下👇:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;span style=&quot;color: #666;&quot;&gt;优先级&lt;/span&gt;</span><br></pre></td></tr></table></figure>
<p>6、5级：！important。示例如下👇:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.foo &#123; color: #fff!important; &#125;</span><br></pre></td></tr></table></figure>
<h4 id="优先级计算规则"><a href="#优先级计算规则" class="headerlink" title="优先级计算规则"></a>优先级计算规则</h4><p>一般来说，我们都是通过数值计算法来计算选择器的优先级。其中，出现一个0级选择器，优先级数值+0；出现一个1级选择器，优先级数值+1；出现一个2级选择器，优先级数值+10；出现一个三级选择器，优先级数值+100；详细的计算规则可以看下表👇:</p>
<table>
<thead>
<tr>
<th align="left">选择器</th>
<th align="left">计算值</th>
<th align="left">计算细则</th>
</tr>
</thead>
<tbody><tr>
<td align="left">* {}</td>
<td align="left">0</td>
<td align="left">1个0级通配选择器，优先级数值为0</td>
</tr>
<tr>
<td align="left">dialog {}</td>
<td align="left">1</td>
<td align="left">1个1级标签选择器，优先级数值为1</td>
</tr>
<tr>
<td align="left">ul &gt; li {}</td>
<td align="left">2</td>
<td align="left">2个1级标签选择器， 1个0级选择器选择符，优先级数值为1+0+1</td>
</tr>
<tr>
<td align="left">li &gt; ol + ol {}</td>
<td align="left">3</td>
<td align="left">3个1级标签选择器， 2个0级选择器选择符，优先级数值为1+0+1+0+1</td>
</tr>
<tr>
<td align="left">.foo {}</td>
<td align="left">10</td>
<td align="left">1个2级</td>
</tr>
<tr>
<td align="left">a:not([ref=nofollow]) {}</td>
<td align="left">11</td>
<td align="left">1个1级选择器，1个0级否定伪类，1个2级属性选择器，优先级数值为1+0+10</td>
</tr>
<tr>
<td align="left">a:hover {}</td>
<td align="left">11</td>
<td align="left">1个1级选择器，1个2级伪类，优先级数值为1+10</td>
</tr>
<tr>
<td align="left">ol li.foo {}</td>
<td align="left">12</td>
<td align="left">1个2级类名选择器，2个1级标签选择器，1个0级空格选择福，优先级数值为1+0+1+10</td>
</tr>
<tr>
<td align="left">li.foo.bar {}</td>
<td align="left">21</td>
<td align="left">1个1级标签选择器，2个2级类名选择器，优先级数值为1+10*2</td>
</tr>
<tr>
<td align="left">#foo {}</td>
<td align="left">100</td>
<td align="left">1个三级ID选择器，优先级数值为100</td>
</tr>
<tr>
<td align="left">#foo .bar p</td>
<td align="left">111</td>
<td align="left">1个三级ID选择器，1个2级类名选择器，1个1级标签选择器，优先级数值为100+10+1</td>
</tr>
</tbody></table>
<p>好啦，现在我们再来看一下开头的题目</p>
<hr>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh-CN"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span> <span class="attr">class</span>=<span class="string">'foo'</span>&gt;</span>颜色是？<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">body</span><span class="selector-class">.foo</span><span class="selector-pseudo">:not(</span><span class="selector-attr">[dir]</span>) &#123; <span class="attribute">color</span>: red; &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">html</span><span class="selector-attr">[lang]</span> &gt; <span class="selector-class">.foo</span> &#123; <span class="attribute">color</span>: blue; &#125;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>首先是body.foo:not([dir])，出现了1个标签选择器body，1个类名选择器.foo和一个否定伪类:not，以及属性选择器[dir]，计算结果是1+10+0+10,也就是21。<br>接下来是html[lang] &gt; .foo，出现了1个标签选择器html,1个属性选择器[lang]和1个类名选择器.foo，计算结果是1+10+10,也就是21。<br>如果两个选择器的计算结果一致，那该怎么渲染呢？<br>这个时候，我们需要知道 <strong>“后来居上”</strong> 的原则。也就是说，当选择器优先级一致时，后渲染的选择器的优先级更高。因此，上题的答案就是蓝色（不知道大家都做对了吗～）</p>
<h4 id="增加CSS选择器优先级的小技巧"><a href="#增加CSS选择器优先级的小技巧" class="headerlink" title="增加CSS选择器优先级的小技巧"></a>增加CSS选择器优先级的小技巧</h4><hr>
<p>实际开发过程中，难免会遇到需要增加CSS选择器优先级的场景。例如，希望增加下面.foo类名选择器的权重：<br><code>.foo { color: #333; }</code><br>大部分人的做法是增加嵌套，例如：<br><code>.father .foo { color: #666; }</code><br>或者是增加一个标签选择器，例如；<br><code>div.foo { color: #555; }</code><br>但是，这些都不是最好的方法，因为这些方法增加类耦合，降低了可维护性，最简单的一个小技巧就是 <strong>重复选择器自身</strong>，像下面这样，既提高了优先级没有不会增加耦合：<br><code>.foo.foo {  }</code><br>如果不喜欢上面这种写法，借助必然会存在的属性选择器也是不错的方法：<br><code>.foo[class] {}</code><br><code>#foo[id] {}</code></p>
]]></content>
      <tags>
        <tag>Css3</tag>
      </tags>
  </entry>
  <entry>
    <title>css世界的层叠规则</title>
    <url>/2019/12/05/css-stack-index/</url>
    <content><![CDATA[<p>身为一个前端er，css一直是我们最为基本的技能，而css的中文翻译就是层叠样式表。那为什么css世界的规则是基于‘层叠上下文’？我们又该怎么理解元素的层叠顺序？对于z-index的负值又该怎么理解？接下来，我们就基于一张图来好好谈谈css的层叠规则。<br>废话不对说，先祭出图👇👇👇👇👇👇👇<br><img src="https://raw.githubusercontent.com/wq931030/albums/master/2019/index.png" alt="图一"></p>
<a id="more"></a>
<h2 id="理解css的层叠上下文和层叠水平"><a href="#理解css的层叠上下文和层叠水平" class="headerlink" title="理解css的层叠上下文和层叠水平"></a>理解css的层叠上下文和层叠水平</h2><hr>
<p>很多人对于css的层叠，第一反应想到的就是z-index属性。在实际项目中，往往我们都是通过对定位元素（position不为static）设置z-index来实现我们想要的层叠关系。但是，随着css3的发展，现在z-index已经并非只有对定位元素才有效，flex盒子的子元素也可以设置z-index属性。而且网页中的绝大部分元素是非定位元素，影响层叠顺序的属性远不止z-index，我只能说，css没你想的那么简单哦😯</p>
<h3 id="理解元素的层叠顺序"><a href="#理解元素的层叠顺序" class="headerlink" title="理解元素的层叠顺序"></a>理解元素的层叠顺序</h3><p>这里我们首先对开始祭出的图来做个补充说明</p>
<ul>
<li>位于最下面的background/border特指层叠上下文元素的边框和背景色。每一个层叠顺序规则仅适用于当前层叠上下文元素的小世界</li>
<li>内联元素的层叠顺序要高于浮动和块级元素。一般来说，像底层的background/border是装饰属性，浮动元素和块级元素用作布局，而内联元素都是内容。所以，记住喽😊，<strong>网页中最重要的就是内容</strong></li>
</ul>
<h3 id="层叠黄金准则"><a href="#层叠黄金准则" class="headerlink" title="层叠黄金准则"></a>层叠黄金准则</h3><p>一般来说，当元素发生层叠的时候，其覆盖关系遵循下面两条准则：<br>（1）谁大谁在上：在同一层叠上下文领域，层叠水平大的覆盖小的那个（z-index大的在上面）<br>（2）后来居上：元素的层叠水平一致，层叠顺序相同的时候，DOM流中处于后面的元素会覆盖前面的元素</p>
<h2 id="深入了解层叠上下文"><a href="#深入了解层叠上下文" class="headerlink" title="深入了解层叠上下文"></a>深入了解层叠上下文</h2><hr>
<h3 id="层叠上下文的创建"><a href="#层叠上下文的创建" class="headerlink" title="层叠上下文的创建"></a>层叠上下文的创建</h3><p>层叠上下的创建概括来说可以有一下三种方式：</p>
<ul>
<li>页面根元素天生具有层叠上下文，称为根层叠上下文</li>
<li>z-index值为数值的定位元素的传统“层叠上下文”，这个也是我们最熟悉的一种啦</li>
<li>由css3属性引起的</li>
</ul>
<h4 id="定位元素与传统层叠上下文"><a href="#定位元素与传统层叠上下文" class="headerlink" title="定位元素与传统层叠上下文"></a>定位元素与传统层叠上下文</h4><p>对于position值为relative/absolute/fixe的，当其z-index值不是auto的时候，会创建层叠上下文。<br>先来看一下第一个例子：<br>HTML代码如下👇</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">'position:relative;z-index:auto;'</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 树 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">'tree.jpeg'</span> <span class="attr">style</span>=<span class="string">'position:absolute;z-index:2;'</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">'position:relative;z-index:auto;'</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 马--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">'ma.jpg'</span> <span class="attr">width</span>=<span class="string">'100'</span> <span class="attr">style</span>=<span class="string">'position:absolute;z-index:1;'</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>结果如下图所示，效果符合预期。<br><img src="https://raw.githubusercontent.com/wq931030/albums/master/2019/layer2.png" alt=""><br>现在对父级简单调整一下，把z-index：auto改成层叠水平一样高的z-index：0，代码如下👇</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">'position:relative;z-index:0;'</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 树 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">'tree.jpg'</span> <span class="attr">style</span>=<span class="string">'position:absolute;z-index:2;'</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">'position:relative;z-index:0;'</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 马--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">'ma.jpg'</span> <span class="attr">style</span>=<span class="string">'position:absolute;z-index:1;'</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>结果如下图所示，覆盖关系反了过来(🐂👃)！！！<br><img src="https://raw.githubusercontent.com/wq931030/albums/master/2019/layer1.png" alt=""><br>为什么小小的改动，竟然会有这么大的差异呢？关键就在于z-indx：auto所在的div元素是一个<strong>普通定位元素</strong>，于是，里面的img的层叠比较不受父级影响，两者直接套用层叠准则，<strong>z-index大的在上面</strong>。<br>而当z-index变为数值，哪怕是0，也会立刻创造一个层叠上下文，所以此时img元素的层叠顺序比较就变成优先比较父级的顺序。由于两个父级z-index都是0，此时根据DOM文档流后面的元素覆盖前面的这个原则，就出现了上图的结果。<br>没想到简单的一个z-index属性，也能搞出这么多的花样，css世界水果然很深🏊‍♀️🏊‍♀️🏊‍♀️</p>
<h4 id="css3与新时代的层叠上下文"><a href="#css3与新时代的层叠上下文" class="headerlink" title="css3与新时代的层叠上下文"></a>css3与新时代的层叠上下文</h4><p>当出现以下css3属性的时候，也会形成层叠上下文哦：<br>1、 元素为flex布局，同时z-index值不是auto<br>2、 元素的opacity值不是1<br>3、 元素的transform值不是none<br>4、 元素的filetr属性不是none<br>5、 元素mix-blend-mode值不是normal<br>6、 元素的isolation值不是isolate<br>7、 元素的will-change属性值为上面2-6的任意一个<br>8、 <strong>元素的-webkit-overflow-scrolling设为touch</strong>(当初做移动端项目就在这点上被坑到了😭)</p>
<h2 id="z-index负值深入理解"><a href="#z-index负值深入理解" class="headerlink" title="z-index负值深入理解"></a>z-index负值深入理解</h2><hr>
<p>是不是第一次知道z-index竟然可以支持负值？（反正我不是🤷‍♀️）z-index的具体规则又是怎么样的呢？<br>一般来说，z-index负值元素的层级是在层叠上下文上面、block元素的下面，也就是z-index虽然名为负数层级，但依然无法突破当前层叠上下文所控制的区域。<br>先看一个例子加深一下认识👇：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>.box非层叠上下文元素<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'box'</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">'1.jpg'</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>.box是层叠上下文元素<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'box content'</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">'1.jpg'</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;!<span class="selector-tag">--</span> <span class="selector-tag">CSS</span> <span class="selector-tag">--</span>&gt;</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> &gt; <span class="selector-tag">img</span> &#123; </span><br><span class="line">  <span class="attribute">position</span>: relative; </span><br><span class="line">  <span class="attribute">z-index</span>: -<span class="number">1</span>; </span><br><span class="line">  <span class="attribute">right</span>: -<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.context</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale</span>(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现的效果👇👇👇👇<br><img src="https://raw.githubusercontent.com/wq931030/albums/master/2019/layer3.png" alt=""><br>那么z-index负值在实际项目中又有上面用呢？具体作用如下：</p>
<ul>
<li><strong>可访问属性隐藏。</strong> z-index负值可以隐藏元素，只需要层叠上下文内的某一个父元素加个背景色就可以</li>
<li><strong>定位在元素的后面。</strong> 我们可以先看一个模拟纸张效果的例子👇</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'page'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h4</span> <span class="attr">class</span>=<span class="string">'title'</span>&gt;</span>一些示例文字<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;!<span class="selector-tag">--</span> <span class="selector-tag">Style</span> <span class="selector-tag">--</span>&gt;</span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#666</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.page</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f4f39e</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(to bottom, #f4f39e, #f5da41 60%, #fe6);</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">2px</span> <span class="number">10px</span> <span class="number">1px</span> <span class="built_in">rgba</span>(0, 0, 0, .2);</span><br><span class="line">    <span class="attribute">text-shadow</span>: <span class="number">0</span> <span class="number">1px</span> <span class="number">0</span> <span class="number">#f6ef97</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.page</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">skew</span>(-15deg) <span class="built_in">rotate</span>(-5deg);</span><br><span class="line">    <span class="attribute">transform-origin</span>: left bottom;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.page</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">skew</span>(15deg) <span class="built_in">rotate</span>(5deg);</span><br><span class="line">    <span class="attribute">transform-origin</span>: right bottom;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 边角卷边阴影 */</span></span><br><span class="line"><span class="selector-class">.page</span><span class="selector-pseudo">:before</span>, <span class="selector-class">.page</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">90%</span>; <span class="attribute">height</span>: <span class="number">20%</span>;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">8px</span> <span class="number">16px</span> <span class="built_in">rgba</span>(0, 0, 0, .3);</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">z-index</span>: -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实现效果</strong>👇</p>
<p><img src="https://raw.githubusercontent.com/wq931030/albums/master/2019/layer4.png" alt=""></p>
<blockquote>
<p><strong>解释一下</strong>：<br>.container灰色背景通过position:relative;z-index:0创建了层叠上下文，.page仅有position:relative而没有设置z-index,因此只能算z-index:auto程度的定位元素，于是，z-index：-1两个边角阴影就完美地藏在了层叠上下文（灰色背景）之上，普通定位元素（黄色纸张）之下，隐藏了丑陋的细节，展示了完美的边角阴影，实现了最终细腻的样式效果🎉🎉🎉</p>
</blockquote>
<h2 id="z-index“不犯二”准则"><a href="#z-index“不犯二”准则" class="headerlink" title="z-index“不犯二”准则"></a>z-index“不犯二”准则</h2><hr>
<p>其准则内容如下：对于非浮动元素，避免设置z-index值，z-index值没有任何理由要超过2（瞬间想到项目里面z-index：9999😷😷😷）。至于原因，有以下几条：</p>
<ul>
<li>定位元素一旦设置了z-index，就从普通元素变成了层叠上下文，相互间的层叠顺序就发生了根本的变化，很容易出现设置了巨大的z-index值也无法覆盖其他元素的问题。</li>
<li>避免z-index‘一山比一山高’的样式混乱问题。想想自己在项目开发过程中，有没有出现过这种情况：a同事对一个元素设置了z-index：99，结果这个值比b同事设置的弹框的z-index还要高，于是b把弹框的z-index设置为了9999，然后可怕的是如果弹框上面还要有出错提示效果….显然，最后项目的z-index层级管理就是一团糟。</li>
</ul>
]]></content>
      <tags>
        <tag>Css3</tag>
      </tags>
  </entry>
  <entry>
    <title>猜数字</title>
    <url>/2019/11/26/leecode02/</url>
    <content><![CDATA[<blockquote>
<p>题目描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小A 和 小B 在玩猜数字。小B 每次从 1, 2, 3 中随机选择一个，小A 每次也从 1, 2, 3 中选择一个猜。他们一共进行三次这个游戏，请返回 小A 猜对了几次？</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p><strong>输入的guess数组为 小A 每次的猜测，answer数组为 小B 每次的选择。guess和answer的长度都等于3。</strong></p>
<blockquote>
<p>示例1</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：guess = [1,2,3], answer = [1,2,3]</span><br><span class="line">输出：3</span><br><span class="line">解释：小A 每次都猜对了。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>示例2</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：guess = [2,2,3], answer = [3,2,1]</span><br><span class="line">输出：1</span><br><span class="line">解释：小A 只猜对了第二次。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>限制</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">guess的长度 = 3</span><br><span class="line">answer的长度 = 3</span><br><span class="line">guess的元素取值为 &#123;1, 2, 3&#125; 之一。</span><br><span class="line">answer的元素取值为 &#123;1, 2, 3&#125; 之一。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>小白的解题思路：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">只要for循环就可以实现了</span><br></pre></td></tr></table></figure>
<blockquote>
<p>题解</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; guess</span><br><span class="line"> * @param &#123;number[]&#125; answer</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var game = function(guess = [], answer = []) &#123;</span><br><span class="line">  return guess.reduce((count, item, index) =&gt; &#123;</span><br><span class="line">    if (item === answer[index]) count++</span><br><span class="line">    return count</span><br><span class="line">  &#125;, 0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeeCode系列</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>图片居中神器：object-fit</title>
    <url>/2019/11/22/css3-object-fit/</url>
    <content><![CDATA[<p>最近小白在看<a href="https://youzan.github.io/vant" target="_blank" rel="noopener">Vant</a>的文档，它里面有个Image图片组件，可以实现多种填充模式（类似于background），于是一时好奇，查看了源码，结果发现vant是使用了一个Object-fit的属性❓❓❓一脸蒙蔽之后，立马google终于知道了Object-fit是个啥东东。</p>
<a id="more"></a>]]></content>
      <categories>
        <category>Css3</category>
      </categories>
  </entry>
  <entry>
    <title>两数之和</title>
    <url>/2019/11/20/leecode01/</url>
    <content><![CDATA[<p>作为一名软件工程专业毕业的程序媛，想当年也是半夜刷ACM刷到嗨的人。好几年没写过算法题，感觉脑子都快更不上啦！所以决定开一个LeeCode刷刷刷系列，来个每周一题，大家一起来开刷啊！！</p>
<a id="more"></a>
<blockquote>
<p>题目描述: 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。<br><strong>示例</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 nums = [2, 7, 11, 15], target = 9</span><br><span class="line">因为 nums[0] + nums[1] = 2 + 7 = 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure>
<p><strong>小白的解题思路：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">最简单粗暴的方法肯定是两次for循环，但是这样时间复杂度就是$O(n^2),对于追求性能的前端er来说，这怎么行呢！！</span><br><span class="line">进一步优化，可以通过一个map来存储其中的一个值，然后只需要一次循环去匹配剩下的值就可以l</span><br></pre></td></tr></table></figure>
<p><strong>解题代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var twoSum = function(nums, target) &#123;</span><br><span class="line">  const map = new Object()</span><br><span class="line">  for (var i=0; i&lt; nums.length; i++) &#123;</span><br><span class="line">    const number = target - nums[i]</span><br><span class="line">    if(number in map) &#123;</span><br><span class="line">      return [map[number], i]</span><br><span class="line">    &#125;</span><br><span class="line">    map[nums[i]] = i</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>执行结果</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">执行用时 : 72 ms</span><br><span class="line">内存消耗 : 34.3 MB</span><br></pre></td></tr></table></figure>
<p><strong>leecode大牛最佳方案</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var twoSum = function(nums, target, i = 0, maps = &#123;&#125;) &#123;</span><br><span class="line">  const map = maps</span><br><span class="line">  if(map[target - nums[i] ] &gt;= 0 ) &#123;</span><br><span class="line">      return [ map[target - nums[i] ], i]</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    map[ nums[i] ] = i;</span><br><span class="line">    i++;</span><br><span class="line">    if(i &lt; nums.length - 1)&#123;</span><br><span class="line">      return twoSum(nums, target, i, map)</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">      throw &apos;error: twoSum is not find&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeeCode系列</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始基于Hexo+Github搭建个人博客</title>
    <url>/2019/11/20/blog1/</url>
    <content><![CDATA[<p>身为一名程序媛，平时遇到问题就会各种google大法，然后从别人的博客里面寻找答案，小白心里一直希望可以拥有一个属于自己博客，所有这次也是断断续续的花了一天两的时间，折腾出了人生第一个博客🎉🎉🎉🎉🎉，期间也是踩了大大小小的坑😭。话不多说，接下来，小白老师手把手教你怎么搭建一个炫酷（装逼）的博客！</p>
<a id="more"></a>
<hr>
<h3 id="Step1-安装Hexo"><a href="#Step1-安装Hexo" class="headerlink" title="Step1 安装Hexo"></a>Step1 安装Hexo</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Step2-GitHub创建个人博客仓库"><a href="#Step2-GitHub创建个人博客仓库" class="headerlink" title="Step2 GitHub创建个人博客仓库"></a>Step2 GitHub创建个人博客仓库</h3><ul>
<li>登陆GitHub，如果没有账号的话，就点<a href="https://github.com/" target="_blank" rel="noopener">这里</a>注册git账号，然后点击右上角+，选择New repository</li>
<li>填写仓库名，<strong>注意：</strong>这里仓库名必须是<strong>你的github账号.github.io</strong>这种格式，举个例子，看下图小白的配置👇<br><img src="https://raw.githubusercontent.com/wq931030/albums/master/2019/20191120165241.png" alt="s"></li>
<li><a href="https://help.github.com/en/github/authenticating-to-github/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent" target="_blank" rel="noopener">配置SSH Key</a>, 已经配过的可以忽略跳过</li>
</ul>
<hr>
<h3 id="Step3-初始化Blog项目"><a href="#Step3-初始化Blog项目" class="headerlink" title="Step3 初始化Blog项目"></a>Step3 初始化Blog项目</h3><ul>
<li>本地选择一个文件夹，用来存放blog项目，然后依次运行下面的脚本👇👇👇<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init blog</span><br></pre></td></tr></table></figure></li>
<li>确保git部署<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li>
<li>生成文章页面，打开本地浏览<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>tips: 以后每次文章更新之后，都需要执行hexo g重新生成页面</strong></p>
<p>接下来，浏览器输入：<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000 </a>, 就可以看到你的博客啦🎉🎉🎉～</p>
<p><img src="https://raw.githubusercontent.com/wq931030/albums/master/2019/20191120171641.png" alt="s"><br>是不是觉得很丑，一点也不能让你装逼让你飞，别急<br>接下来我们一步步来完善博客的功能</p>
<hr>
<h4 id="变更主题"><a href="#变更主题" class="headerlink" title="变更主题"></a>变更主题</h4><p><a href="https://hexo.io/zh-cn/index.html" target="_blank" rel="noopener">Hexo</a>身为一个热门的博客框架，自然少不了一堆好看的主题。作为一个颜控，就算是博客，也需要高颜值。你可以在<a href="https://hexo.io/themes/" target="_blank" rel="noopener">主题库</a>里面选择一个自己中意的样式下载安装，这里小白选择的是<a href="https://github.com/zhwangart/hexo-theme-ocean" target="_blank" rel="noopener">Ocean</a>（太好看啦，为数学家疯狂打☎️☎️☎️☎️☎️）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/zhwangart/hexo-theme-ocean.git themes/ocean</span><br></pre></td></tr></table></figure>
<p>然后打开站点的_config.yml(博客配置文档), 将<strong>theme</strong>设置为<strong>ocean</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure>
<p>清除缓存，重新构建之后，你的博客样式就变啦，瞬间屌丝逆袭有木有🎉🎉🎉🎉🎉🎉</p>
<p><img src="https://raw.githubusercontent.com/wq931030/albums/master/2019/20191120173120.png" alt="d"></p>
<h4 id="添加评论功能"><a href="#添加评论功能" class="headerlink" title="添加评论功能"></a>添加评论功能</h4><p>ocean默认是关闭评论功能的，我们需要以下步骤来实现该功能</p>
<ul>
<li>github 申请oauth apps<br>个人中心点击settings/Developer settings<br><img src="https://github.com/zhwangart/gitalk/raw/master/source/Register-OAuth-application.png" alt="s"><br>说明：<ul>
<li>Application name: 没有限制的 APP 名称，比如：Hexo-application</li>
<li>Homepage URL: 网站的主页，我理解就是根目录，比如 <a href="https://wq931030.github.io">https://wq931030.github.io</a></li>
<li>Application description: 描述，非必填</li>
<li>Authorization callback URL: 回调 url 我理解就是网站的域名，比如 <a href="https://wq931030.github.io">https://wq931030.github.io</a><br>申请成功之后，就看到有了 Client ID 与 Client Secret 的一个页面，页面下边就是申请刚填写的的信息，均可以再次编辑！ 只有 Client ID 与 Client Secret 是在配置 Hexo 的时候需要用。<br><img src="https://raw.githubusercontent.com/wq931030/albums/master/2019/20191120193757.png" alt="s"></li>
</ul>
</li>
<li>修改主题下的_config.yml文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Gitalk</span><br><span class="line">gitalk:</span><br><span class="line">  enable: true # true</span><br><span class="line">  clientID: # GitHub Application Client ID</span><br><span class="line">  clientSecret: # Client Secret</span><br><span class="line">  repo: wq931030.github.io # Repository name</span><br><span class="line">  owner: wq931030 # GitHub ID</span><br><span class="line">  admin: wq931030 # GitHub ID</span><br></pre></td></tr></table></figure>
接下来就可以愉快的对博文发表评论啦🎉🎉🎉🎉🎉🎉</li>
</ul>
<hr>
<h3 id="Step4-Blog关联GitHub"><a href="#Step4-Blog关联GitHub" class="headerlink" title="Step4 Blog关联GitHub"></a>Step4 Blog关联GitHub</h3><p>现在，你的博客可以在本地浏览了，接下来我们就来让它可以通过github的线上地址进行访问<br>还是打开站点的_config.yml，修改以下配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:wq931030/wq931030.github.io.git #这里就是step2创建的仓库地址</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>然后安装git部署依赖,这样就可以把代码部署到github上去啦～</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>接下来执行以下脚本,  完成部署</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d #部署</span><br></pre></td></tr></table></figure>
<p>铛铛铛铛，接下来，就可以用<a href="http://wq931030.github.io">http://wq931030.goithub.io</a>来访问博客啦<br>是不是很激动，很幸福，<br><strong>但是</strong><br>身为一个有追求的人，当然想让博客能有自己的域名<br>那么就接着折腾吧</p>
<hr>
<h3 id="Step4-配置阿里云域名"><a href="#Step4-配置阿里云域名" class="headerlink" title="Step4 配置阿里云域名"></a>Step4 配置阿里云域名</h3><p>这里小白选用的是<a href="https://wanwang.aliyun.com/" target="_blank" rel="noopener">阿里云</a>的域名，小伙伴们可以根据自己的情况来定哦</p>
<ul>
<li>注册完自己的域名之后，接下来需要设置域名解析<br>1、 登录<a href="https://dns.console.aliyun.com/?spm=a2c4g.11186623.2.12.d00459cbLH4MmF#/dns/domainList" target="_blank" rel="noopener">云解析DNS控制台</a><br>2、 添加域名<br>3、 在域名解析页面，点击域名，进入解析设置页面<br>4、 在项目里，ping你自己的yourname.github.io获取到ip地址：<br>  <img src="https://raw.githubusercontent.com/wq931030/albums/master/2019/20191120185908.png" alt="s"><br>5、 添加两条记录<br>  <img src="https://raw.githubusercontent.com/wq931030/albums/master/2019/20191120185030.png" alt="s"></li>
<li>本地blog项目新建一个CNAME文件（没有任何后缀）,然后在里面写上你的个人域名</li>
<li>GitHub项目添加域名<br>进入项目仓库，点击settings，往下拉，在Custom domain这一部分填上你的域名<br><img src="https://raw.githubusercontent.com/wq931030/albums/master/2019/20191120185625.png" alt="s"></li>
</ul>
<p>接下来，等待一段时间<br>然后<br>你就可以用域名打开你的博客啦🎉🎉🎉🎉🎉🎉～～～～～</p>
<hr>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/11/17/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
